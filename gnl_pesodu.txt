line:



//pre_condition: char * line is NULL;
gnl:
	
char	*help_line;

help_line = get_static_var(list); //should be a new mem location, even is 										//only '\0';


line = strdup(help_line);
free(help_line);
help_line = NULL;
if last symbol is '\n':
	return (1);
else:
	while	read buf
		if buf has '\n':
			copy everything to line;
			join line, free;
			remainder to list;
			return (1);
		else:
			help_line = join buff;
			



static:

return char_static : contain the value of the static var, a new mem location


pointer after free, what does it points to?



list:
insert: to the tail;
get data from the head;

init:
static NULL
reg_buf -2
helper_line ft_strnew();
*line  null

{
read static, helper_line: strnew; '\0'; 
get_node_data(**list, **helper)

check newline:
	if has newline,
		strdup to helper;
		free  helper;
		return (1);  				if (get_node_data return (1))
										line = strdup(helper)
										free(helper)
										return (1);
									read buf
	else
		strdup the whole content to helper
	reg_read unknown
	static: minus one '\n' or static NULL
}


return (1):
reg_buf > 0
helper_line terminated by '\n'
static: NULL

//pre:
//helper_line contain a string without ending new line
//static NULL
{
	reg_read > 0:       buf, helper, readbyte, line t_list
	if buf has newline:    search new line(*buf, len) ---> index

		joint to helper    strnjoint (*old, *new, len)
		strdup to line;    strndup (*old, len)
		free helper        free
		
		remainder to static;   copy_remainder(*buf, len, **list)
		return (1);
	else
		joint to helper;       strjoint(*old, *new)
		free helper;			
}


return (0):
file end with no newline:
reg_buf = 0;
helper_line terminate with '\0':
static: NULL(must be)
free(helper_line);

{
  		if helper '\0' and static NULL 
			return (0);
		else
			helper joint line;
			free (helper);
			return (1);	
}


typedef	struct	s_list
{
	char	*content;
	t_list	next
}			t_list;






























